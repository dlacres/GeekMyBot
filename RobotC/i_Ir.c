#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_Matrix_S1_1, wheelRt,       tmotorMatrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, wheelLt,       tmotorMatrix, PIDControl, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motorF,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, motorG,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, irSvo,                tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
// As a programmer I want to autonomously line up with the IR beacon so that I can score points.
//
//======================================================//
// Usage:
// Region ----- Width in Degrees - Comments
// -------------------------------------------
// 1         - Sensor 1
// 2-----14  -   This is created when 2 sensors both see light
// 3-----54  - Sensor 2
// 4-----6   -   This is created when 2 sensors both see light
// 5-----67  - Sensor 3 This wide area is the front of the sensor
// 6-----6   -   This is created when 2 sensors both see light
// 7-----54  - Sensor 4
// 8-----3   -   This is created when 2 sensors both see light
// 9         - Sensor 5

//  Notes: Region to the left (top view) 1,2,3,4 Forward 5, region to right 6,7,8,9
//    Use transtions between regions to set a steering command.
#include "include/hitechnic-irseeker-v2.h"

// Create struct to hold sensor data
tHTIRS2 irSeeker;
//---------------------- IrInit --------------------------//
void IrInit(){

  // Look for the 1200 hz IR AC signal
  irSeeker.mode = DSP_1200;

  // Initialise and configure struct and port
  initSensor(&irSeeker, S2);
}
//---------------------- Ir ------------------------------//
#define CMD_GAIN 1
int Ir(){
	int irCmd=0;
	readSensor(&irSeeker);

	if (irSeeker.acDirection==0) irCmd=0;
	else if (irSeeker.acDirection<3) irCmd=3*CMD_GAIN;
	else if (irSeeker.acDirection<4) irCmd=2*CMD_GAIN;
	else if (irSeeker.acDirection>5) irCmd=-3*CMD_GAIN;
	else if (irSeeker.acDirection>4) irCmd=-2*CMD_GAIN;
	else if (irSeeker.acValues[1]>irSeeker.acValues[2]) irCmd=1*CMD_GAIN;
	else irCmd=-1*CMD_GAIN;

	return(irCmd);
}
// ==================UNIT TEST==========================//
#ifndef NO_UNIT_TEST
#include "i_debug.c"
#include "i_integrate.c"
#include "JoystickDriver.c"

int timeLeft=0; // A global variable used to adjust the time it takes to complet the while loop
int i=0;
int svoCmdZ1=128;
int robCmdZ1=0;
int scanCmdZ1=128;
bool runTest=true;
#define INC 0
#define DEC 1
#define STOP 0
#define TURN_SVO 1
#define TURN_ROBOT 2
#define SCAN_SVO_PLUS 3
#define SCAN_SVO_MINUS 4
#define JOY 5

short sm=0;
#pragma DebuggerWindows("joystickGame");
//-----------------Joystick Commands--------------------
//  joy1Btn(5) (Top Back Left)	(6) (Top Back Right)
//         (6) (Bottom)		      (8) (Bottom)
//
//                           0      (9)  (10)    (4)
//  joystick.joy1_TopHat== 6   2							(1)   (3)
//                           4                   (2)
//
//        joystick.joy1_y1 / x1  ...  y2 / x2
//------------------------------------------------------

#define FOREGROUND_MS 50 //The while loop takes 50 MS to run. This means the software runs 20 times per second
task main(){
	// Initialize variables here //
	int cmd=0;
	int svoPos,svoCmd;
	int irSensorCur=0;
	int irSensorOld=0;
	int jstickX = 0;
	int jstickY = 0;

	IrInit();

	//Debug2File(); //Send the debug information to the file debug.txt
	//Debug2NXT();  //Send the debug information to the NXT screen
	Debug2Stream(); //Send the debug information to the PC Screen

	// End of initialize //
	while(runTest){
		clearTimer(T1);
		hogCPU(); //Prevent other tasks from running when this one is.
		// ------------- Put Unit Test code here -------------------//
		// xxxxxxx [] IR Off - Servo should sit still
		// xxxxxxx [] IR On and left of center - Servo should move to center
		// xxxxxxx [] IR On and right of center - Servo should move to center

		// USAGE NOTES:
		//   The units for a are encoder clicks
		//   Set #define NO_UNIT_TEST

		cmd=Ir();

		// ------- Joystick Control --------//
		getJoystickSettings(joystick);

		jstickX = Lookup1(joystick.joy1_x2);// - DeadZone((SensorValue[gyroSensor]-gyroBias)/2,5);
		jstickY = Lookup1(joystick.joy1_y2);


		switch (sm){
		case STOP:

			jstickY=jstickX=0;

			break;
		case TURN_SVO:
			servo[irSvo]=svoPos=IntegrateInt(cmd, 0, 255, svoCmdZ1);

			irSensorOld=irSensorCur;
			irSensorCur=irSeeker.acDirection;
			if (irSensorCur!=irSensorOld || irSensorCur==4){
				DebugInt("SvoCmd",svoCmd);
				DebugInt("SvoPos",svoPos);
				DebugInt("IrDir",irSeeker.acDirection);
				DebugPrint();
			}


			jstickY=jstickX=0;

			if ((bool)joy1Btn(1)) sm=TURN_SVO;
			if ((bool)joy1Btn(2)) sm=TURN_ROBOT;
			if ((bool)joy1Btn(3)) sm=SCAN_SVO_MINUS;

			break;
		case SCAN_SVO_MINUS:
			servo[irSvo]=svoPos=IntegrateInt(-1, 0, 255, scanCmdZ1);

			irSensorOld=irSensorCur;
			irSensorCur=irSeeker.acDirection;
			if (irSensorCur!=irSensorOld || irSensorCur==4){
				DebugInt("SvoCmd",-1);
				DebugInt("SvoPos",svoPos);
				DebugInt("IrDir",irSeeker.acDirection);
				DebugPrint();
			}


			jstickY=jstickX=0;

			if ((bool)joy1Btn(1)) sm=TURN_SVO;
			if ((bool)joy1Btn(2)) sm=TURN_ROBOT;
			if ((bool)joy1Btn(3)) sm=SCAN_SVO_MINUS;
			if (svoPos==0) sm=SCAN_SVO_PLUS;
			break;
		case SCAN_SVO_PLUS:
			servo[irSvo]=svoPos=IntegrateInt(1, 0, 255, scanCmdZ1);

			irSensorOld=irSensorCur;
			irSensorCur=irSeeker.acDirection;
			if (irSensorCur!=irSensorOld || irSensorCur==4){
				DebugInt("SvoCmd",1);
				DebugInt("SvoPos",svoPos);
				DebugInt("IrDir",irSeeker.acDirection);
				DebugPrint();
			}

			jstickY=jstickX=0;

			if ((bool)joy1Btn(1)) sm=TURN_SVO;
			if ((bool)joy1Btn(2)) sm=TURN_ROBOT;
			if ((bool)joy1Btn(3)) sm=SCAN_SVO_MINUS;
			if (svoPos==255) sm=SCAN_SVO_MINUS;
			break;
		case TURN_ROBOT:

			jstickX=cmd*5;


			if ((bool)joy1Btn(1)) sm=TURN_SVO;
			if ((bool)joy1Btn(2)) sm=TURN_ROBOT;
			if ((bool)joy1Btn(3)) sm=SCAN_SVO_MINUS;
			break;
		case JOY:
			//=svoPos=IntegrateInt(1, -1000, 1000, robCmdZ1);
			if ((bool)joy1Btn(1)) sm=TURN_SVO;
			if ((bool)joy1Btn(2)) sm=TURN_ROBOT;
			if ((bool)joy1Btn(3)) sm=SCAN_SVO_MINUS;
			break;
	  }

	  // ------- Control the drive motors ----------//
		motor[wheelLt]=(jstickY + jstickX);
		motor[wheelRt]=(jstickY - jstickX);


		i+=1; // Increment the frame counter for unit test
		// ------------- Unit code test is done here ---------------//
		timeLeft=FOREGROUND_MS-time1[T1]; // Calculate the time used in the foreground
		releaseCPU(); // Let other tasks run now.
		wait1Msec(timeLeft);// The time other tasks have to run before foreground takes control.
	}// While Loop
}// Main Task
#endif
